package main

import (
	"errors"
	"fmt"
	"math/big"
	"os"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/ethereum/go-ethereum/crypto"
	distributorContract "github.com/pk910/testnet-funding-tool-go/distributor"
	flag "github.com/spf13/pflag"
)

type CliArgs struct {
	verbose              bool
	fundings             string
	rpchost              string
	privkey              string
	randomPrivKey        bool
	maxPending           uint
	gaslimit             uint64
	maxfeepergas         float32
	maxpriofee           float32
	output               string
	summary              string
	chainid              uint64
	nonce                uint64
	useDistributor       bool
	distributorAddr      string
	distributorBatchSize uint
	input                string
}

type Summary struct {
	transferCount    uint
	transactionCount uint
	totalAmount      *big.Int
	distributor      string
}

type TxHandler interface {
	ProcessTx(txBytes []byte)
}

func main() {
	cliArgs := CliArgs{}

	flag.BoolVarP(&cliArgs.verbose, "verbose", "v", false, "Run the script with verbose output")
	flag.StringVarP(&cliArgs.fundings, "fundings", "f", "", "The list of fundings (list of address:amount lines)")
	flag.StringVarP(&cliArgs.rpchost, "rpchost", "r", "http://127.0.0.1:8545", "The RPC host to send transactions to.")
	flag.StringVarP(&cliArgs.privkey, "privkey", "p", "", "The private key of the wallet to send funds from.\n(Special: \"env\" to read from FUNDINGTOOL_PRIVKEY environment variable)")
	flag.BoolVar(&cliArgs.randomPrivKey, "random-privkey", false, "Use random private key if no privkey supplied")
	flag.UintVarP(&cliArgs.maxPending, "maxpending", "m", 10, "The maximum number of parallel pending transactions.")
	flag.Uint64Var(&cliArgs.gaslimit, "gaslimit", 500000, "The gas limit for transactions.")
	flag.Float32Var(&cliArgs.maxfeepergas, "maxfeepergas", 20, "The gas limit for transactions.")
	flag.Float32Var(&cliArgs.maxpriofee, "maxpriofee", 1.2, "The maximum priority fee per gas in gwei.")
	flag.StringVarP(&cliArgs.output, "output", "o", "", "Output list of signed transactions to file instead of broadcasting them (offline mode).")
	flag.StringVarP(&cliArgs.input, "input", "i", "", "File with list of signed transactions to send (used to publish the transactions generated by this tool via the --output flag).")
	flag.StringVarP(&cliArgs.summary, "summary", "s", "", "Output summary of distribution to file.")
	flag.Uint64Var(&cliArgs.chainid, "chainid", 0, "ChainID of the network (For offline mode in combination with --output)")
	flag.Uint64Var(&cliArgs.nonce, "nonce", 0, "Current nonce of the wallet (For offline mode in combination with --output)")
	flag.BoolVar(&cliArgs.useDistributor, "use-distributor", false, "Use a distribution contract.")
	flag.StringVar(&cliArgs.distributorAddr, "distributor-addr", "", "Use a already deployed distributor contract at this address.")
	flag.UintVar(&cliArgs.distributorBatchSize, "distributor-batch-size", 20, "The max size of transaction batches to send via the distributor contract.")

	flag.Parse()

	var walletState *WalletState
	if cliArgs.input != "" {
		// publish transactions from input file

		walletState = &WalletState{}
		err := walletState.InitOnlineMode(cliArgs.rpchost)
		if err != nil {
			printHelp()
			fmt.Printf("Invalid or inaccessible RPC Host \"%v\": %v\n", cliArgs.rpchost, err)
			fmt.Println("")
			return
		}

		txlist, err := OpenInputTxList(cliArgs.input)
		if err != nil {
			fmt.Printf("Could not open input list: %v\n", err)
			fmt.Println("")
			return
		}

		txsender, err := StartTxSender(walletState, cliArgs.maxPending)
		if err != nil {
			fmt.Printf("Could not start tx sender: %v\n", err)
			fmt.Println("")
			return
		}
		txsender.verbose = cliArgs.verbose

		for txlist.scanner != nil {
			txBytes := txlist.GetNextEntry()
			if txBytes == nil {
				break
			}
			txsender.ProcessTx(txBytes)
		}

		txsender.Await()

	} else {
		// build (and publish) funding transactions

		if cliArgs.fundings == "" {
			printHelp()
			fmt.Println("No funding list specified.")
			fmt.Println("")
			return
		}
		fundingList, err := OpenFundingList(cliArgs.fundings)
		if err != nil {
			fmt.Printf("Could not open funding list: %v\n", err)
			fmt.Println("")
			return
		}

		walletState, err = loadPrivkey(&cliArgs)
		if err != nil {
			printHelp()
			fmt.Printf("Could not load private key: %v\n", err)
			fmt.Println("")
			return
		}

		if cliArgs.output != "" {
			// offline mode
			if cliArgs.chainid == 0 {
				printHelp()
				fmt.Println("chainid argument is required for offline mode.")
				fmt.Println("")
				return
			}
			walletState.InitOfflineMode(cliArgs.chainid, cliArgs.nonce)
		} else {
			err := walletState.InitOnlineMode(cliArgs.rpchost)
			if err != nil {
				printHelp()
				fmt.Printf("Invalid or inaccessible RPC Host \"%v\": %v\n", cliArgs.rpchost, err)
				fmt.Println("")
				return
			}
			fmt.Printf("Initialized Wallet: %v, balance: %v ETH, nonce: %v\n", walletState.address.String(), GetEthAmount(walletState.balance), walletState.nonce)
		}

		// process all fundings
		summary, err := processFundings(&cliArgs, fundingList, walletState)
		if err != nil {
			fmt.Printf("Error while processing fundings: %v\n", err)
			return
		}

		if cliArgs.summary != "" {
			// output summary
			summaryFile, err := os.OpenFile(cliArgs.summary, os.O_CREATE|os.O_WRONLY|os.O_TRUNC, 0644)
			if err != nil {
				fmt.Printf("Could not open summary file %v: %v\n", cliArgs.summary, err)
				return
			}
			summaryFile.WriteString(fmt.Sprintf("WalletAddress: %v\n", walletState.address.String()))
			summaryFile.WriteString(fmt.Sprintf("TotalAmountWei: %v\n", summary.totalAmount.String()))
			summaryFile.WriteString(fmt.Sprintf("TotalAmountEth: %v\n", GetEthAmount(summary.totalAmount)))
			summaryFile.WriteString(fmt.Sprintf("TransactionCount: %v\n", summary.transactionCount))
			summaryFile.WriteString(fmt.Sprintf("TransferCount: %v\n", summary.transferCount))
			if summary.distributor != "" {
				summaryFile.WriteString(fmt.Sprintf("DistributorAddr: %v\n", summary.distributor))
			}
			summaryFile.Close()
		}
	}

	fmt.Println("Finished successfully.")
}

func printHelp() {
	fmt.Println("Testnet Funding Tool")
	fmt.Println("A simple tool that sends funds to the specified accounts.")
	fmt.Println("")
	fmt.Println("Options")
	flag.PrintDefaults()
	fmt.Println("")
}

func loadPrivkey(cliArgs *CliArgs) (*WalletState, error) {
	privkey := cliArgs.privkey
	if privkey == "env" {
		privkey = os.Getenv("FUNDINGTOOL_PRIVKEY")
	}
	if privkey == "" && !cliArgs.randomPrivKey {
		return nil, errors.New("No private key specified.")
	}

	walletState := WalletState{}
	err := walletState.LoadPrivateKey(privkey)
	return &walletState, err
}

func processFundings(cliArgs *CliArgs, fundingList *FundingList, wallet *WalletState) (*Summary, error) {
	summary := Summary{
		totalAmount: new(big.Int),
	}

	var txhandler TxHandler
	var txsender *TxSender
	if cliArgs.output != "" {
		txlist, err := OpenOutputTxList(cliArgs.output)
		if err != nil {
			return nil, err
		}
		txhandler = txlist
	} else {
		var err error
		txsender, err = StartTxSender(wallet, cliArgs.maxPending)
		if err != nil {
			return nil, err
		}
		txsender.verbose = cliArgs.verbose
		txhandler = txsender
	}

	var distributor *common.Address
	if cliArgs.useDistributor {
		var contractAddr common.Address
		if cliArgs.distributorAddr != "" {
			parsedAddr := common.HexToAddress(cliArgs.distributorAddr)
			contractAddr = common.BytesToAddress(parsedAddr.Bytes())
		} else {
			code := common.Hex2Bytes(distributorContract.DistributorBin[2:])
			contractAddr = common.BytesToAddress(crypto.CreateAddress(wallet.address, wallet.nonce).Bytes())
			feeCap := uint64(cliArgs.maxfeepergas * 1000000000)
			tipCap := uint64(cliArgs.maxpriofee * 1000000000)
			tx, err := wallet.BuildDeployTransaction(code, feeCap, tipCap, 500000)
			if err != nil {
				fmt.Printf("Error during distributor deployment: %v\n", err)
			}

			txBytes, txHash := serializeTransaction(tx)
			txhandler.ProcessTx(txBytes)
			fmt.Printf("Deployed distributor contract: %v\n", common.BytesToHash(txHash).String())
		}

		fmt.Printf("Using distributor contract: %v\n", contractAddr.String())
		distributor = &contractAddr
		summary.distributor = contractAddr.String()
	} else {
		summary.distributor = ""
	}

	printProgress := func() {
		fmt.Printf("Processing distributions... progress: %v\n", fundingList.lineidx)
	}
	printProgress()
	var lastProgress uint = 0
	for fundingList.scanner != nil {
		var txBytes []byte
		var txHash []byte
		if distributor == nil {
			txBytes, txHash = buildNextFundingTxSingle(cliArgs, fundingList, wallet, &summary)
		} else {
			txBytes, txHash = buildNextFundingTxBatch(cliArgs, fundingList, wallet, distributor, &summary)
		}
		if txBytes == nil || txHash == nil {
			continue
		}

		if cliArgs.verbose {
			fmt.Printf("  tx hash: 0x%v\n", common.Bytes2Hex(txHash))
		}
		txhandler.ProcessTx(txBytes)

		if fundingList.lineidx-lastProgress > 1000 {
			lastProgress = fundingList.lineidx
			printProgress()
		}
	}

	if txsender != nil {
		txsender.Await()
		//txsender.Stop()
	}

	return &summary, nil
}

func buildNextFundingTxSingle(cliArgs *CliArgs, fundingList *FundingList, wallet *WalletState, summary *Summary) ([]byte, []byte) {
	fundingEntry := fundingList.GetNextEntry()
	if fundingEntry == nil {
		return nil, nil
	}
	if cliArgs.verbose {
		fmt.Printf("Process funding %v: %v ETH\n", fundingEntry.address.String(), GetEthAmount(fundingEntry.amount))
	}
	if !wallet.offline && fundingEntry.amount.Cmp(wallet.balance) > 0 {
		fmt.Printf("  amount exceeds wallet balance (amount: %v, balance: %v)\n", GetEthAmount(fundingEntry.amount), GetEthAmount(wallet.balance))
		return nil, nil
	}

	feeCap := uint64(cliArgs.maxfeepergas * 1000000000)
	tipCap := uint64(cliArgs.maxpriofee * 1000000000)

	tx, err := wallet.BuildEthTransaction(fundingEntry.address, fundingEntry.amount, feeCap, tipCap, cliArgs.gaslimit, []byte{})
	if err != nil {
		fmt.Printf("  error while building transaction: %v\n", err)
		return nil, nil
	}

	summary.transactionCount++
	summary.transferCount++
	summary.totalAmount.Add(summary.totalAmount, fundingEntry.amount)

	return serializeTransaction(tx)
}

func buildNextFundingTxBatch(cliArgs *CliArgs, fundingList *FundingList, wallet *WalletState, distributor *common.Address, summary *Summary) ([]byte, []byte) {
	batchEntries := make([]*FundingEntry, 0, cliArgs.distributorBatchSize)
	var batchAmount *big.Int = nil
	totalAmount := big.NewInt(0)
	allSameAmount := true
	allEthAmount := true
	allGweiAmount := true
	addrsBytes := make([]byte, 0, cliArgs.distributorBatchSize*20)

	for i := 0; i < int(cliArgs.distributorBatchSize); i++ {
		entry := fundingList.GetNextEntry()
		if entry == nil {
			break
		}
		batchEntries = append(batchEntries, entry)
		totalAmount = totalAmount.Add(totalAmount, entry.amount)

		if batchAmount == nil {
			batchAmount = entry.amount
		} else if batchAmount.Cmp(entry.amount) != 0 {
			allSameAmount = false
		}

		var unitFactor *big.Int
		var restAmount *big.Int = &big.Int{}

		unitFactor = big.NewInt(1000000000000000000)
		restAmount = restAmount.Mod(entry.amount, unitFactor)
		if restAmount.Cmp(big.NewInt(0)) != 0 {
			allEthAmount = false
		}

		unitFactor = big.NewInt(1000000000)
		restAmount = restAmount.Mod(entry.amount, unitFactor)
		if restAmount.Cmp(big.NewInt(0)) != 0 {
			allGweiAmount = false
		}

		addrsBytes = append(addrsBytes, entry.address.Bytes()...)
	}

	distributorAbi, err := distributorContract.DistributorMetaData.GetAbi()
	if err != nil {
		fmt.Printf("  error while loading distributor abi: %v\n", err)
		return nil, nil
	}

	var callData []byte
	if allSameAmount { // all same amount, use distributeEqual(bytes calldata addrs)
		var err error
		callData, err = distributorAbi.Pack("distributeEqual", addrsBytes)
		if err != nil {
			fmt.Printf("  error while building distributeEqual call data: %v\n", err)
		}
	} else if allEthAmount { // only full ether amounts, use distributeEther(bytes calldata addrs, uint32[] calldata values)
		amounts := make([]uint32, len(batchEntries))
		for i := 0; i < len(batchEntries); i++ {
			amount := big.Int{}
			amount.Div(batchEntries[i].amount, big.NewInt(1000000000000000000))
			amounts[i] = uint32(amount.Uint64())
		}
		var err error
		callData, err = distributorAbi.Pack("distributeEther", addrsBytes, amounts)
		if err != nil {
			fmt.Printf("  error while building distributeEther call data: %v\n", err)
		}
	} else if allGweiAmount { // only full gwei amounts, use distributeGwei(bytes calldata addrs, uint64[] calldata values)
		amounts := make([]uint64, len(batchEntries))
		for i := 0; i < len(batchEntries); i++ {
			amount := big.Int{}
			amount.Div(batchEntries[i].amount, big.NewInt(1000000000))
			amounts[i] = amount.Uint64()
		}
		var err error
		callData, err = distributorAbi.Pack("distributeGwei", addrsBytes, amounts)
		if err != nil {
			fmt.Printf("  error while building distributeGwei call data: %v\n", err)
		}
	} else { // use distribute(bytes calldata addrs, uint256[] calldata values)
		amounts := make([]*big.Int, len(batchEntries))
		for i := 0; i < len(batchEntries); i++ {
			amounts[i] = &big.Int{}
			amounts[i].Div(batchEntries[i].amount, big.NewInt(1000000000))
		}
		var err error
		callData, err = distributorAbi.Pack("distribute", addrsBytes, amounts)
		if err != nil {
			fmt.Printf("  error while building distributeGwei call data: %v\n", err)
		}
	}

	//fmt.Printf("  call data: %v\n", common.Bytes2Hex(callData))

	if !wallet.offline && totalAmount.Cmp(wallet.balance) > 0 {
		fmt.Printf("  batch amount exceeds wallet balance (amount: %v, balance: %v)\n", GetEthAmount(totalAmount), GetEthAmount(wallet.balance))
		return nil, nil
	}

	feeCap := uint64(cliArgs.maxfeepergas * 1000000000)
	tipCap := uint64(cliArgs.maxpriofee * 1000000000)

	tx, err := wallet.BuildEthTransaction(distributor, totalAmount, feeCap, tipCap, cliArgs.gaslimit, callData)
	if err != nil {
		fmt.Printf("  error while building transaction: %v\n", err)
		return nil, nil
	}

	summary.transactionCount++
	summary.transferCount += uint(len(batchEntries))
	summary.totalAmount.Add(summary.totalAmount, totalAmount)

	return serializeTransaction(tx)
}

func serializeTransaction(tx *types.Transaction) ([]byte, []byte) {
	txBytes, err := tx.MarshalBinary()
	if err != nil {
		fmt.Printf("  error while serializing transaction: %v\n", err)
		return nil, nil
	}

	return txBytes, tx.Hash().Bytes()
}
